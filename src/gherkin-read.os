//----------------------------------------------------------
//This Source Code Form is subject to the terms of the
//Mozilla Public License, v.2.0. If a copy of the MPL
//was not distributed with this file, You can obtain one
//at http://mozilla.org/MPL/2.0/.
//----------------------------------------------------------

////////////////////////////////////////////////////////////////////////////////////////////////////
//
// Объект-помощник для чтения/разбора файлов функциональностей BDD - *.feature в формате Gherkin
//
////////////////////////////////////////////////////////////////////////////////////////////////////

#Использовать logos
#Использовать asserts
#Использовать strings

Перем Лог;

Перем СоответствиеЯзыкКлючевыеСлова;
Перем СоответствиеКлючевыеСлова;

Перем ОписанияЛексем;
Перем ВозможныеТипыШагов;
Перем ВозможныеТипыНачалаСтроки;
Перем ВозможныеКлючевыеСлова;
Перем ВозможныеКлючиПараметров;
Перем ВозможныеХуки;

Перем УровниЛексем;
Перем ТипыШагов;

Перем РегулярныеВыражения;
Перем НаборЗаменДляНормализацииАдресаШага;

////////////////////////////////////////////////////////////////////
//{ Программный интерфейс

Функция ПрочитатьФайлСценария(Знач ФайлСценария) Экспорт
	Если НРег(ФайлСценария.Расширение) <> ".feature" Тогда
		ВызватьИсключение "Неверный файл фичи " + ФайлСценария.ПолноеИмя;
	КонецЕсли;

	Лог.Отладка("Читаю сценарий %1", ФайлСценария.ПолноеИмя);
	Фича = Новый ЧитательСтрокФайла;
	Фича.Инициализировать(ФайлСценария.ПолноеИмя);

	СтруктураФичи = РазобратьТекстФичи(Фича);
	// НайденныеЛексемы = СтруктураФичи.НайденныеЛексемы;

	Фича.Закрыть();

	Возврат СтруктураФичи;
КонецФункции

// Прочитать текст фичи
//
// Параметры:
//   ТекстФичи - Строка - текст фичи
//
//  Возвращаемое значение:
//   Структура - структура описания разбора фичи
//
Функция ПрочитатьТекстФичи(Знач ТекстФичи) Экспорт

	Лог.Отладка("Читаю текст фичи");
	Фича = Новый ЧитательСтрокФайла;
	Фича.ИнициализироватьИзСтроки(ТекстФичи);

	СтруктураФичи = РазобратьТекстФичи(Фича);

	Фича.Закрыть();

	Возврат СтруктураФичи;
КонецФункции

// Возвращает фиксированную структуру с типами шагов.
//		Выполняется кеширование этой структуры
//
//  Возвращаемое значение:
//   ФиксированнаяСтруктура - Ключ - тип шага, значение - соответствующее уникальное имя шага
//
Функция ВозможныеТипыШагов() Экспорт
	Если ВозможныеТипыШагов = Неопределено Тогда
		Рез = Новый Структура;
		Рез.Вставить("Функциональность", ВозможныеКлючевыеСлова.Функциональность);
		Рез.Вставить("Контекст", 		ВозможныеКлючевыеСлова.Контекст);
		Рез.Вставить("Сценарий", 		ВозможныеКлючевыеСлова.Сценарий);
		Рез.Вставить("СтруктураСценария", ВозможныеКлючевыеСлова.СтруктураСценария);
		Рез.Вставить("Примеры", 		ВозможныеКлючевыеСлова.Примеры);
		Рез.Вставить("Описание", 		ВозможныеКлючевыеСлова.Описание);
		Рез.Вставить("Шаг", 			"Шаг");
		ВозможныеТипыШагов = Новый ФиксированнаяСтруктура(Рез);
	КонецЕсли;
	Возврат ВозможныеТипыШагов;
КонецФункции

// Возвращает фиксированную структуру с ключевыми словами Gherkin.
//		Выполняется кеширование этой структуры
//
//  Возвращаемое значение:
//   ФиксированнаяСтруктура - Ключ - русское имя ключевого слова, значение - уникальное имя
//
Функция ВозможныеКлючевыеСлова() Экспорт
	Если ВозможныеКлючевыеСлова = Неопределено Тогда
		Рез = Новый Структура;
		Рез.Вставить("Допустим", "Допустим");
		Рез.Вставить("Когда", "Когда");
		Рез.Вставить("Тогда", "Тогда");
		Рез.Вставить("Также", "Также");
		Рез.Вставить("Но", "Но");
		Рез.Вставить("Функциональность", "Функциональность");
		Рез.Вставить("Контекст", "Контекст");
		Рез.Вставить("Сценарий", "Сценарий");
		Рез.Вставить("СтруктураСценария", "СтруктураСценария");
		Рез.Вставить("Примеры", "Примеры");
		Рез.Вставить("Описание", "Описание");

		ВозможныеКлючевыеСлова = Новый ФиксированнаяСтруктура(Рез);
	КонецЕсли;
	Возврат ВозможныеКлючевыеСлова;
КонецФункции

// Возвращает фиксированную структуру с кодовыми ключами параметров шагов.
//		Выполняется кеширование этой структуры
//
//  Возвращаемое значение:
//   ФиксированнаяСтруктура - Ключ - русское имя параметра, значение - уникальный код параметра
//
Функция ВозможныеКлючиПараметров() Экспорт
	Если ВозможныеКлючиПараметров = Неопределено Тогда
		Рез = Новый Структура;
		Рез.Вставить("Строка", "[{ПараметрСтрока}]");
		Рез.Вставить("Число", "[{ПараметрЧисло}]");
		Рез.Вставить("Дата", "[{ПараметрДата}]");
		Рез.Вставить("ПараметрДляТаблицы", "[{ПараметрДляТаблицы}]");
		Рез.Вставить("Таблица", "[{Таблица}]");
		ВозможныеКлючиПараметров = Новый ФиксированнаяСтруктура(Рез);
	КонецЕсли;
	Возврат ВозможныеКлючиПараметров;
КонецФункции

// возвращает Структуру, в которой ключ - имя хука, а значение - Структура с ключами АдресШага и ТипШага
Функция ВозможныеХуки() Экспорт
	Если ВозможныеХуки = Неопределено Тогда
		Рез = Новый Структура;
		//TODO добавить возможность единого набора хуков "до выполнения" и "после выполнения" шагов различных типов
		//Например, перед запуском - для сценариев, шагов
		Рез.Вставить("ПередЗапускомСценария",
			Новый Структура("АдресШага,ТипШага", "ПередЗапускомСценария", ВозможныеТипыШагов.Сценарий));
		Рез.Вставить("ПослеЗапускаСценария",
			Новый Структура("АдресШага,ТипШага", "ПослеЗапускаСценария", ВозможныеТипыШагов.Сценарий));
		ВозможныеХуки = Новый ФиксированнаяСтруктура(Рез);
	КонецЕсли;
	Возврат ВозможныеХуки;
КонецФункции // ВозможныеХуки()

// Создает пустое дерево фич
//
//  Возвращаемое значение:
//   ДеревоЗначений -
//
Функция СоздатьДеревоФич() Экспорт
	Рез = Новый ДеревоЗначений;
	Рез.Колонки.Добавить("Лексема");
	Рез.Колонки.Добавить("УровеньЛексемы");
	Рез.Колонки.Добавить("ТипШага");
	Рез.Колонки.Добавить("АдресШага");
	Рез.Колонки.Добавить("Тело");
	Рез.Колонки.Добавить("Параметры");
	Рез.Колонки.Добавить("ПараметрыДляТаблицы");
	Рез.Колонки.Добавить("ЕстьПараметрыДляТаблицы");
	Рез.Колонки.Добавить("СтатусВыполнения");
	Рез.Колонки.Добавить("ОписаниеОшибкиВыполнения");
	Возврат Рез;
КонецФункции

// Нормализовать адрес шага, приведя его к единому формату шагов
//
// Параметры:
//   АдресШага - Строка - идентификатор шага
//
//  Возвращаемое значение:
//   Строка - единый формат шага
//
Функция НормализоватьАдресШага(Знач АдресШага) Экспорт
	Возврат ВРег(АдресШага);
КонецФункции // НормализоватьАдресШага()

// TODO перенести экспортный метод СформироватьАдресШага в начало метода
Функция СформироватьАдресШага(Знач ТелоШага) Экспорт
	АдресШага = "";

	Лог.Отладка("ТелоШага %1", ТелоШага);

	МассивПодстрок = СтроковыеФункции.РазложитьСтрокуВМассивПодстрок(ТелоШага, " ", Истина);
	Для Каждого Элемент Из МассивПодстрок Цикл
		Если ЭтоКлючПараметра(Элемент) Тогда
			Лог.Отладка("Пропускаю Элемент %1", Элемент);
			Продолжить;
		КонецЕсли;
		АдресШага = АдресШага + ТРег(Элемент);
	КонецЦикла;
	Лог.Отладка("АдресШага (1) %1", АдресШага);

	Для каждого КлючЗначение Из НаборЗаменДляНормализацииАдресаШага Цикл
		АдресШага = СтрЗаменить(АдресШага, КлючЗначение.Ключ, КлючЗначение.Значение);
	КонецЦикла;

	Лог.Отладка("АдресШага (2) %1", АдресШага);

	Возврат АдресШага;
КонецФункции

Функция ПараметрИсключенияДляЕщеНеРеализованногоШага() Экспорт
	Возврат "Не реализовано.";
КонецФункции

// Возвращает уникальное имя функции получения списка шагов в файлах реализаций шагов
//
//  Возвращаемое значение:
//   Строка - "ПолучитьСписокШагов"
//
Функция НаименованиеФункцииПолученияСпискаШагов() Экспорт
	Возврат "ПолучитьСписокШагов";
КонецФункции

// Возвращает имя лога 1bdd
//
//  Возвращаемое значение:
//   Строка - имя лога
Функция ИмяЛога() Экспорт
	Возврат "bdd";
КонецФункции

// Скопировать все реквизиты узла дерева и все подчиненные строки
//
// Параметры:
//   Узел - ДеревоЗначений, СтрокаДереваЗначений - источник
//   УзелИсходногоДерева - ДеревоЗначений, СтрокаДереваЗначений - получатель
//
Процедура СкопироватьДерево(Узел, УзелИсходногоДерева) Экспорт
	ЗаполнитьЗначенияСвойств(Узел, УзелИсходногоДерева, , "Родитель, Строки, Параметры, ПараметрыДляТаблицы");

	Узел.Параметры = СоздатьТаблицуПараметров();
	ДобавитьПараметры(Узел.Параметры, УзелИсходногоДерева.Параметры);

	Узел.ПараметрыДляТаблицы = СоздатьТаблицуПараметров();
	ДобавитьПараметры(Узел.ПараметрыДляТаблицы, УзелИсходногоДерева.ПараметрыДляТаблицы);
	Для каждого Строка Из УзелИсходногоДерева.Строки Цикл
		НоваяСтрока = Узел.Строки.Добавить();
		СкопироватьДерево(НоваяСтрока, Строка);
	КонецЦикла;
КонецПроцедуры

// Вывести отладочные сообщения о полном составе дерева
//
// Параметры:
//   Узел - ДеревоЗначений, СтрокаДереваЗначений  - исходный узел для показа
//   Отступ - Строка - Количество пробелов слева для форматирования вывода каждого узла
//   ВыводитьШапку - Истина - заголовочные и конечные сообщения для обрамления
//
Процедура ПоказатьДеревоВРежимеОтладки(Узел, Знач Отступ = "", Знач ВыводитьШапку = Истина) Экспорт
	Если ВыводитьШапку Тогда
		Лог.Отладка(СтроковыеФункции.ДополнитьСлеваМногострочнуюСтроку("
		|  ------------------- Текущее дерево -------------------
		|", Отступ));
	КонецЕсли;

	Попытка
		Лог.Отладка(СтрШаблон("%4 тип шага %1, лексема %2, тело %3, адрес шага %5",
				Узел.ТипШага, Узел.Лексема, Узел.Тело, Отступ, Узел.АдресШага));
		Родитель = Узел.Родитель;
		Лог.Отладка(СтрШаблон("%4     родитель тип шага %1, лексема %2, тело %3, адрес шага %5",
				Родитель.ТипШага, Родитель.Лексема, Родитель.Тело, Отступ, Родитель.АдресШага));
	Исключение
		// скрываем ошибки
	КонецПопытки;

	Для каждого Строка Из Узел.Строки Цикл
		ПоказатьДеревоВРежимеОтладки(Строка, Отступ + "  ", Ложь);
	КонецЦикла;

	Если ВыводитьШапку Тогда
		Лог.Отладка(СтроковыеФункции.ДополнитьСлеваМногострочнуюСтроку("
		|  ------------------- -------------------
		|", Отступ));
	КонецЕсли;
КонецПроцедуры

// Универсальная функция для проверки наличия свойств у значения любого типа данных
//
// Параметры:
//   Коллекция - Любой - Коллекция любого типа, для которой необходимо проверить наличие свойства
//   ИмяСвойства - Строка - имя проверяемого свойства
//
//  Возвращаемое значение:
//   Булево - <описание возвращаемого значения>
//
Функция ЕстьСвойство(Знач Коллекция, Знач ИмяСвойства)
	СтруктураПроверка = Новый Структура;
	СтруктураПроверка.Вставить(ИмяСвойства, NULL);

	ЗаполнитьЗначенияСвойств(СтруктураПроверка, Коллекция);

	// Если значение для свойства структуры осталось NULL, то искомое свойство не найдено, и наоборот.
	Если СтруктураПроверка[ИмяСвойства] = NULL Тогда
		Возврат Ложь;
	Иначе
		Возврат Истина;
	КонецЕсли;
КонецФункции

//}

////////////////////////////////////////////////////////////////////
//{ Реализация

Функция РазобратьТекстФичи(Знач Фича)

	НайденныеЛексемы = Новый Массив;
	ПредыдущиеПараметрыЛексемы = Неопределено;
	ПредыдущаяЛексема = Неопределено;
	ДлинаСтрокиНачалаМногострочногоТекста = СтрДлина(ВозможныеТипыНачалаСтроки.МногострочныйТекст);
	Язык = Неопределено;

	Пока Истина Цикл
		ОчереднаяСтрока = ПолучитьОчереднуюСтрокуФичи(Фича);
		Если ОчереднаяСтрока = Неопределено Тогда
			Прервать;
		КонецЕсли;

		ПервыйСимвол = Лев(ОчереднаяСтрока, 1);
		Если ПервыйСимвол = ВозможныеТипыНачалаСтроки.Комментарий Тогда
			НовыйЯзык = ПолучитьЯзыкФичи(ОчереднаяСтрока);
			Если ЗначениеЗаполнено(НовыйЯзык) Тогда
				Язык = НовыйЯзык;
				СоответствиеКлючевыеСлова = СоответствиеЯзыкКлючевыеСлова.Получить(Язык);
				Лог.Отладка("	Получили язык фичи " + Язык);
			КонецЕсли;
			Продолжить;

		ИначеЕсли ПервыйСимвол = ВозможныеТипыНачалаСтроки.Метка Тогда
			Лог.Отладка("	Первый символ строки - это метка. Пропускаю строку");
			Продолжить;

		ИначеЕсли ПервыйСимвол = ВозможныеТипыНачалаСтроки.Таблица
				И НЕ ПредыдущиеПараметрыЛексемы.ДалееБудутДополнительныеСтроки Тогда
			Лог.Отладка("Очередная строка фичи <%1>", ОчереднаяСтрока);

			ПредыдущиеПараметрыЛексемы.ЕстьТелоТаблицы = Истина;
			ПредыдущиеПараметрыЛексемы.ДопТело = ПолучитьТелоТаблицыДанных(Фича, ОчереднаяСтрока);

			Лог.Отладка("Добавляю таблицу данных как часть предыдущей лексемы. Тело <%1>", ПредыдущиеПараметрыЛексемы.ДопТело);
			Продолжить;

		ИначеЕсли Лев(ОчереднаяСтрока, ДлинаСтрокиНачалаМногострочногоТекста) = ВозможныеТипыНачалаСтроки.МногострочныйТекст Тогда
			Лог.Отладка("Очередная строка фичи <%1>", ОчереднаяСтрока);

			ПредыдущиеПараметрыЛексемы.ЕстьМногострочнаяСтрока = Истина;

			ПраваяЧасть = ПредыдущиеПараметрыЛексемы.ПраваяЧасть +
				?(ПустаяСтрока(ПредыдущиеПараметрыЛексемы.ПраваяЧасть), "", Символы.ПС);
			ПредыдущиеПараметрыЛексемы.ПраваяЧасть = ПраваяЧасть + ПолучитьМногострочныйТекст(Фича);
			Лог.Отладка("Добавляю многострочный текст как часть предыдущей лексемы. Тело %1",
				ПредыдущиеПараметрыЛексемы.ПраваяЧасть);
			Продолжить;

		КонецЕсли;

		Лог.Отладка("Очередная строка фичи <%1>", ОчереднаяСтрока);

		Ожидаем.Что(Язык, "Ожидали, что язык фичи " + Язык + " будет установлен в тексте фичи, но это не так").Заполнено();

		ИспользоватьНовуюЛексемуКакЧастьПредыдущейЛексемы = ЗначениеЗаполнено(ПредыдущиеПараметрыЛексемы)
			И ПредыдущиеПараметрыЛексемы.ДалееБудутДополнительныеСтроки;

		ПараметрыЛексемы = НайтиЛексему(ОчереднаяСтрока);
		Если ЗначениеЗаполнено(ПараметрыЛексемы) И (НЕ ИспользоватьНовуюЛексемуКакЧастьПредыдущейЛексемы
				ИЛИ ПараметрыЛексемы.Лексема <> ВозможныеКлючевыеСлова.Описание) Тогда
			Лог.Отладка("Использую новую лексему как основную");
			ПредыдущиеПараметрыЛексемы = ПараметрыЛексемы;
			НайденныеЛексемы.Добавить(ПараметрыЛексемы);
		Иначе
			Лог.Отладка("Добавляю новую лексему как часть предыдущей лексемы");
			ПраваяЧасть = ПредыдущиеПараметрыЛексемы.ПраваяЧасть +
				?(ПустаяСтрока(ПредыдущиеПараметрыЛексемы.ПраваяЧасть), "", Символы.ПС);
			ПредыдущиеПараметрыЛексемы.ПраваяЧасть = ПраваяЧасть + ОчереднаяСтрока;
		КонецЕсли;
	КонецЦикла;

	Лог.Отладка("Нашли лексем %1", НайденныеЛексемы.Количество());

	ДеревоФич = ПолучитьДеревоФич(НайденныеЛексемы);

	РезультатыРазбора = Новый Структура;
	РезультатыРазбора.Вставить("Язык", Язык);
	РезультатыРазбора.Вставить("НайденныеЛексемы", НайденныеЛексемы);
	РезультатыРазбора.Вставить("ДеревоФич", ДеревоФич);
	Возврат РезультатыРазбора;
КонецФункции

Функция НайтиЛексему(Знач Строка)
	Ожидаем.Что(СоответствиеКлючевыеСлова, "Ожидали, что найдем ключевые слова, но не нашли").Заполнено();

	Рез = Новый Структура;
	Рез.Вставить("Лексема", Неопределено);
	Рез.Вставить("ПраваяЧасть", "");
	Рез.Вставить("ДалееБудутДополнительныеСтроки", Ложь);
	Рез.Вставить("ДопТело", "");
	Рез.Вставить("ЕстьТелоТаблицы", Ложь);
	Рез.Вставить("ЕстьМногострочнаяСтрока", Ложь);

	СтрокаДляПоиска = НРег(Строка);
	Для каждого КлючЗначение Из СоответствиеКлючевыеСлова Цикл
		Лексема = КлючЗначение.Ключ;
		КлючевоеСлово = КлючЗначение.Значение;
		Позиция = Найти(СтрокаДляПоиска, Лексема);
		Если Позиция = 1 Тогда
			ДлинаЛексемы = СтрДлина(Лексема);
			ИспользоватьРазделительЛексемы = Прав(Лексема, 1) <> ":";
			Если ИспользоватьРазделительЛексемы Тогда

				Символ = Сред(Строка, ДлинаЛексемы + 1, 1);
				Если (Символ <> " ") И НЕ ПустаяСтрока(Символ) Тогда
					//ЛОг.Отладка("Пропускаю лексему <"+Лексема+">, т.к. следующий символ <"+Символ+">");
					Продолжить;
				КонецЕсли;

			КонецЕсли;
			ПраваяЧасть = СокрЛП(Сред(Строка, ДлинаЛексемы + 1));

			ДалееБудутДополнительныеСтроки = КлючевоеСлово = ВозможныеКлючевыеСлова.Примеры;
			Если Прав(ПраваяЧасть, 1) = ":" Тогда
				ДалееБудутДополнительныеСтроки = Ложь;
				ПраваяЧасть = Лев(ПраваяЧасть, СтрДлина(ПраваяЧасть) - 1);
			КонецЕсли;

			Рез.Вставить("Лексема", КлючевоеСлово);
			Рез.Вставить("ПраваяЧасть", ПраваяЧасть);
			Рез.Вставить("ДалееБудутДополнительныеСтроки", ДалееБудутДополнительныеСтроки);

			лог.Отладка(СтрШаблон("Нашел лексему <%1>, правая часть <%2>, ДалееБудутДополнительныеСтроки %3",
					Рез.Лексема, Рез.ПраваяЧасть, ДалееБудутДополнительныеСтроки));
			Возврат Рез;
		КонецЕсли;
	КонецЦикла;
	Рез.Вставить("Лексема", ВозможныеКлючевыеСлова.Описание);
	Рез.Вставить("ПраваяЧасть", Строка);

	Лог.Отладка("Нашел лексему <%1>, правая часть <%2>", Рез.Лексема, Рез.ПраваяЧасть);
	Возврат Рез;
КонецФункции

Функция ПолучитьОчереднуюСтрокуФичи(Знач Фича, Знач ПропускатьПустыеСтроки = Истина)
	Рез = "";
	Пока Истина Цикл
		ОчереднаяСтрока = Фича.ПрочитатьСтроку();
		Если ОчереднаяСтрока = Неопределено Тогда
			Лог.Отладка("Строки фичи закончились");
			Возврат Неопределено;
		КонецЕсли;

		Если ПропускатьПустыеСтроки Тогда
			Рез = СокрЛП(ОчереднаяСтрока);
			Если Не ПустаяСтрока(Рез) Тогда
				Прервать;
			КонецЕсли;
		Иначе
			Рез = СокрП(ОчереднаяСтрока);
			Прервать;
		КонецЕсли;
	КонецЦикла;

	//Лог.Отладка("Очередная строка фичи <"+Рез+">");
	Возврат Рез;
КонецФункции

Функция ПолучитьДеревоФич(НайденныеЛексемы)
	ДеревоФич = СоздатьДеревоФич();
	Индекс = 0;
	СтрокиДерева = ДеревоФич.Строки;

	ЗаполнитьДеревоФич(НайденныеЛексемы, СтрокиДерева, Индекс);

	ЕстьФичи = ЗначениеЗаполнено(СтрокиДерева);
	Если ЕстьФичи Тогда
		Лог.Отладка(СтроковыеФункции.ДополнитьСлеваМногострочнуюСтроку("
		|  ------------------- Текущее дерево (перед подменой структуры сценария): -------------------
		|", "     "));
		ПоказатьДеревоВРежимеОтладки(ДеревоФич, "	");

		СоздатьНовыеСценарииВУзлахДереваВместоСтруктурыСценария(СтрокиДерева);

		Лог.Отладка(СтроковыеФункции.ДополнитьСлеваМногострочнуюСтроку("
		|  ------------------- Текущее дерево (перед подменой контекстов): -------------------
		|", "     "));
		ПоказатьДеревоВРежимеОтладки(ДеревоФич, "	");

		ВставитьУзлыКонтекстовВУзлыСценариевПодчиненныхКонтексту(СтрокиДерева);
	КонецЕсли;

	Лог.Отладка("
	|Текущее дерево:
	|");
	ПоказатьДеревоВРежимеОтладки(ДеревоФич, "	");

	Возврат ?(ЕстьФичи, ДеревоФич, Неопределено);
КонецФункции

//TODO тяжелая функция, перегружена обязанностями. нужно отрефакторить
Процедура ЗаполнитьДеревоФич(НайденныеЛексемы, СтрокиДерева, Индекс)

	Пока Индекс < НайденныеЛексемы.Количество() Цикл
		ПараметрыОчереднойЛексемы = НайденныеЛексемы[Индекс];
		ОчереднаяЛексема = ПараметрыОчереднойЛексемы.Лексема;
		УровеньЛексемы = УровниЛексем[ОчереднаяЛексема];

		Лог.Отладка("Получил Очередная лексема <%1>, Индекс %2, уровень <%3>, тело <%4>",
				ОчереднаяЛексема, Индекс, УровеньЛексемы, ПараметрыОчереднойЛексемы.ПраваяЧасть);

		НайденныеПараметры = Неопределено;
		ПараметрыДляТаблицы = Неопределено;
		ЕстьПараметрыДляТаблицы = Ложь;
		ПраваяЧастьСДобавленнымиКлючамиПараметров = ИзвлечьПараметры(ПараметрыОчереднойЛексемы, НайденныеПараметры,
				ПараметрыДляТаблицы, ЕстьПараметрыДляТаблицы);
		Лог.Отладка("ПраваяЧастьСДобавленнымиКлючамиПараметров %1", ПраваяЧастьСДобавленнымиКлючамиПараметров);

		ПолнаяПраваяЧасть = ПараметрыОчереднойЛексемы.ПраваяЧасть;
		Если Не ПустаяСтрока(ПараметрыОчереднойЛексемы.ДопТело) Тогда
			ПолнаяПраваяЧасть  = ПолнаяПраваяЧасть  + Символы.ПС + ПараметрыОчереднойЛексемы.ДопТело;
		КонецЕсли;
		НоваяСтрока = ЗаполнитьУзелДереваФич(СтрокиДерева, ОчереднаяЛексема, ПолнаяПраваяЧасть);
		Лог.Отладка("НоваяСтрока.Лексема <%1>", НоваяСтрока.Лексема);
		НоваяСтрока.Параметры = НайденныеПараметры;
		НоваяСтрока.ПараметрыДляТаблицы = ПараметрыДляТаблицы;
		НоваяСтрока.ЕстьПараметрыДляТаблицы = ЕстьПараметрыДляТаблицы;
		НоваяСтрока.ТипШага = ПолучитьТипШагаПоЛексеме(ОчереднаяЛексема);
		НоваяСтрока.АдресШага = СформироватьАдресШага(ПраваяЧастьСДобавленнымиКлючамиПараметров);
		НоваяСтрока.УровеньЛексемы = УровеньЛексемы;

		Индекс = Индекс + 1;
		Если Индекс >= НайденныеЛексемы.Количество() Тогда
			Лог.Отладка("Завершаю изучать лексемы. Индекс %1", Индекс);
			Прервать;
		КонецЕсли;

		НоваяЛексема = НайденныеЛексемы[Индекс].Лексема;
		НовыйУровеньЛексемы = УровниЛексем[НоваяЛексема];

		Лог.Отладка("Проверяю следующую лексему <%1>, Индекс %2, уровень <%3>, верхний уровень %4",
				НоваяЛексема, Индекс, НовыйУровеньЛексемы, УровеньЛексемы);

		Если НовыйУровеньЛексемы = УровеньЛексемы Тогда
			Продолжить;
		ИначеЕсли НовыйУровеньЛексемы > УровеньЛексемы Тогда // здесь должны быть равнозначные узлы. Например, сценарий/примеры
			Лог.Отладка(СтрШаблон("Создаю подчиненный узел дерева фич, лексема %1, Индекс %2, уровень %3",
			НоваяЛексема, Индекс, НовыйУровеньЛексемы));
			ЗаполнитьДеревоФич(НайденныеЛексемы, НоваяСтрока.Строки, Индекс);
		Иначе
			Родитель = НоваяСтрока.Родитель;
			УровеньЛексемыРодителя = Родитель.УровеньЛексемы;
			Лог.Отладка(СтрШаблон("Уровень следующей лексемы меньше уровня текущей лексемы
			|Проверяю уровень родителя <%1>, Индекс %2, уровень <%3>",
			Родитель.Лексема, Индекс, УровеньЛексемыРодителя));
			Если НовыйУровеньЛексемы < УровеньЛексемыРодителя Тогда
				Лог.Отладка("Возвращаюсь на предыдущий уровень дерева фич");
				ЗаполнитьДеревоФич(НайденныеЛексемы, Родитель.Строки, Индекс);
				Возврат;
			Иначе
				Пока Истина Цикл
					Если НовыйУровеньЛексемы <= УровеньЛексемыРодителя Тогда
						Лог.Отладка("Возвращаюсь на предыдущий уровень дерева фич");
						ЗаполнитьДеревоФич(НайденныеЛексемы, Родитель.Родитель.Строки, Индекс);
						Возврат;
					Иначе
						Родитель = Родитель.Родитель;
						Если Родитель = Неопределено Тогда
							Прервать;
						КонецЕсли;
						УровеньЛексемыРодителя = Родитель.УровеньЛексемы;
					КонецЕсли;
				КонецЦикла;
			КонецЕсли;
		КонецЕсли;

	КонецЦикла;

КонецПроцедуры

Функция ЗаполнитьУзелДереваФич(СтрокиДерева, Лексема, Тело)
	НоваяСтрока = СтрокиДерева.Добавить();
	ОписаниеЛексемы = Новый Структура("Лексема,Тело", Лексема, Тело);
	ОписаниеЛексемы.Вставить("Строки", Новый Массив);
	ОписаниеЛексемы.Вставить("Параметры", Новый Массив);
	ЗаполнитьЗначенияСвойств(НоваяСтрока, ОписаниеЛексемы);
	Возврат НоваяСтрока;
КонецФункции

Функция ИзвлечьПараметры(Знач ПараметрыЛексемы, НайденныеПараметры, ПараметрыДляТаблицы, ЕстьПараметрыДляТаблицы)
	Тело = ПараметрыЛексемы.ПраваяЧасть;

	НайденныеПараметры = СоздатьТаблицуПараметров();
	ПараметрыДляТаблицы = СоздатьТаблицуПараметров();

	Если ПараметрыЛексемы.ЕстьМногострочнаяСтрока Тогда
		Тело = ВыделитьПараметрыИзМногострочногоТекста(Тело, НайденныеПараметры);
	КонецЕсли;

	Тело = ВыделитьСтроковыеПараметры(Тело, НайденныеПараметры, "'");
	Тело = ВыделитьСтроковыеПараметры(Тело, НайденныеПараметры, """");
	Лог.Отладка("Тело после выделения строковых параметров %1", Тело);

	Тело = ВыделитьПараметрыДляПодстановкиТаблицы(Тело, НайденныеПараметры, ЕстьПараметрыДляТаблицы);
	Лог.Отладка("Тело после выделения параметров для подстановки в таблицу %1", Тело);

	Если ПараметрыЛексемы.ЕстьТелоТаблицы Тогда
		Тело = СтрШаблон("%1 %2", Тело, ИзвлечьПараметрТаблица(ПараметрыЛексемы.ДопТело, НайденныеПараметры));
		Лог.Отладка("Тело после извлечения параметра-таблицы %1", Тело);
	КонецЕсли;

	Тело = ВыделитьПростыеЗначенияНеСтроки(Тело, НайденныеПараметры);
	Лог.Отладка("Тело после выделения простых значений %1", Тело);

	НайденныеПараметры.Сортировать("Начало");

	Возврат Тело;
КонецФункции

Функция ВыделитьПростыеЗначенияНеСтроки(Знач Тело, НайденныеПараметры)

	Тело = ВыделитьПараметрыДата(Тело, НайденныеПараметры);
	Лог.Отладка("Тело после выделения параметров-дат %1", Тело);

	Тело = ВыделитьЧисловыеПараметры(Тело, НайденныеПараметры);
	Лог.Отладка("Тело после выделения параметров-чисел %1", Тело);

	Возврат Тело;
КонецФункции // ВыделитьПростыеЗначенияНеСтроки()

Функция ВыделитьСтроковыеПараметры(Знач Тело, Параметры, Знач ЗнакКавычки)
	Итератор = Найти(Тело, ЗнакКавычки);
	Если Итератор = 0 Тогда
		Возврат Тело;
	КонецЕсли;
	ИндексВТеле = Итератор;

	ОстатокСтроки = Тело;
	НоваяСтрока = "";

	Пока Итератор > 0 Цикл
		НоваяСтрока = НоваяСтрока + Лев(ОстатокСтроки, Итератор - 1);
		ОстатокСтроки = Сред(ОстатокСтроки, Итератор + 1);

		Итератор = Найти(ОстатокСтроки, ЗнакКавычки);
		ИндексВТеле = ИндексВТеле + Итератор;

		Если Итератор > 0 Тогда
			ЗначениеПараметра = Лев(ОстатокСтроки, Итератор - 1);
			ОстатокСтроки = Сред(ОстатокСтроки, Итератор + 1);

			ОписаниеПараметра = ВозможныеКлючиПараметров.Строка;
			НоваяСтрока = НоваяСтрока + ОписаниеПараметра;
			ДобавитьПараметр(Параметры, ОписаниеПараметра, ЗначениеПараметра, ИндексВТеле);
		Иначе
			НоваяСтрока = НоваяСтрока + ОстатокСтроки;
		КонецЕсли;

		Итератор = Найти(ОстатокСтроки, ЗнакКавычки);
		Если Итератор = 0 Тогда
			НоваяСтрока = НоваяСтрока + ОстатокСтроки;
		КонецЕсли;
	КонецЦикла;

	Лог.Отладка("Выделяю параметр-строка для кавычки %1, новое тело %2", ЗнакКавычки, НоваяСтрока);
	Возврат НоваяСтрока;
КонецФункции

Функция ВыделитьПараметрыИзМногострочногоТекста(Знач Тело, Параметры)
	РегулярноеВыражение = РегулярныеВыражения.МногострочныйТекст;
	КоллекцияГруппСовпадений = РегулярноеВыражение.НайтиСовпадения(Тело);
	Если КоллекцияГруппСовпадений.Количество() = 0 Тогда
		Возврат Тело;
	КонецЕсли;
	НовоеТело = Тело;

	Группа = КоллекцияГруппСовпадений[0];

	ЗначениеПараметра = Группа.Группы[1].Значение;
	Если Прав(ЗначениеПараметра, 1) = Символы.ПС Тогда
		ЗначениеПараметра = Сред(ЗначениеПараметра, 1, СтрДлина(ЗначениеПараметра) - 1);
	КонецЕсли;

	Начало = Группа.Индекс;

	ОписаниеПараметра = ВозможныеКлючиПараметров.Строка;
	ДобавитьПараметр(Параметры, ВозможныеКлючиПараметров.Строка, ЗначениеПараметра, Начало);

	НовоеТело = СтрШаблон("%1 %2", СтрПолучитьСтроку(Лев(НовоеТело, Начало), 1), ОписаниеПараметра);
	Возврат НовоеТело;
КонецФункции // ВыделитьПараметрыИзМногострочногоТекста(НовоеТело, НайденныеПараметры)

Функция ВыделитьЧисловыеПараметры(Знач Тело, Параметры)
	РегулярноеВыражение = РегулярныеВыражения.ЧислоИлиСловоСЧислом;
	КоллекцияГруппСовпадений = РегулярноеВыражение.НайтиСовпадения(Тело);
	Если КоллекцияГруппСовпадений.Количество() = 0 Тогда
		Возврат Тело;
	КонецЕсли;

	НовоеТело = Тело;

	Для к = - КоллекцияГруппСовпадений.Количество() + 1 По 0 Цикл
		Группа = КоллекцияГруппСовпадений[ - к];
		ЗначениеПараметра = Группа.Значение;
		Лог.Отладка("ЗначениеПараметра (Число) %1", ЗначениеПараметра);
		ЭтоЧисловойПараметр = ЭтоЧисло(ЗначениеПараметра);
		ОписаниеПараметра = ?(ЭтоЧисловойПараметр, ВозможныеКлючиПараметров.Число, ВозможныеКлючиПараметров.Строка);
		Если ЭтоЧисловойПараметр Тогда
			ЗначениеПараметра = Число(ЗначениеПараметра);
		КонецЕсли;

		Начало = Группа.Индекс;
		ДобавитьПараметр(Параметры, ОписаниеПараметра, ЗначениеПараметра, Начало);

		Окончание = Группа.Индекс + Группа.Длина;
		НовоеТело = Лев(НовоеТело, Начало) + ОписаниеПараметра + Сред(НовоеТело, Окончание + 1);
	КонецЦикла;

	Возврат НовоеТело;

КонецФункции

Функция ВыделитьПараметрыДата(Знач Тело, Параметры)
	РегулярноеВыражение = РегулярныеВыражения.Дата;
	КоллекцияГруппСовпадений = РегулярноеВыражение.НайтиСовпадения(Тело);
	Если КоллекцияГруппСовпадений.Количество() = 0 Тогда
		Возврат Тело;
	КонецЕсли;

	НовоеТело = Тело;

	Для к = - КоллекцияГруппСовпадений.Количество() + 1 По 0 Цикл
		Группа = КоллекцияГруппСовпадений[ - к];
		ЗначениеПараметра = Группа.Значение;
		Группы = Группа.Группы;
		Лог.Отладка("ЗначениеПараметра (Дата) %1", ЗначениеПараметра);
		ОписаниеПараметра = ВозможныеКлючиПараметров.Дата;

		Год = Группы[3].Значение;
		Если СтрДлина(Год) = 2 Тогда
			Год = "20" + Год;
		КонецЕсли;
		СтрокаДаты = СтрШаблон("%1%2%3", Год, Группы[2].Значение, Группы[1].Значение);
		ЗначениеПараметра = Дата(СтрокаДаты);

		Начало = Группа.Индекс;
		ДобавитьПараметр(Параметры, ОписаниеПараметра, ЗначениеПараметра, Начало);

		Окончание = Группа.Индекс + Группа.Длина;
		НовоеТело = Лев(НовоеТело, Начало) + ОписаниеПараметра + Сред(НовоеТело, Окончание + 1);
	КонецЦикла;

	Возврат НовоеТело;

КонецФункции

Функция ВыделитьПараметрыДляПодстановкиТаблицы(Знач Тело, Параметры, ЕстьПараметрыДляТаблицы)
	РегулярноеВыражение = РегулярныеВыражения.ПараметрДляТаблицы;
	КоллекцияГруппСовпадений = РегулярноеВыражение.НайтиСовпадения(Тело);
	ЕстьПараметрыДляТаблицы = КоллекцияГруппСовпадений.Количество() <> 0;
	Если НЕ ЕстьПараметрыДляТаблицы Тогда
		Возврат Тело;
	КонецЕсли;

	НовоеТело = Тело;

	Для к = - КоллекцияГруппСовпадений.Количество() + 1 По 0 Цикл
		Группа = КоллекцияГруппСовпадений[ - к];
		ЗначениеПараметра = Группа.Группы[1].Значение;
		Лог.Отладка("ЗначениеПараметра (для подстановки из таблицы) %1", ЗначениеПараметра);
		ОписаниеПараметра = ВозможныеКлючиПараметров.ПараметрДляТаблицы;

		Начало = Группа.Индекс;
		ДобавитьПараметр(Параметры, ОписаниеПараметра, ЗначениеПараметра, Начало);

		Окончание = Группа.Индекс + Группа.Длина;
		НовоеТело = Лев(НовоеТело, Начало) + ОписаниеПараметра + Сред(НовоеТело, Окончание + 1);

		Лог.Отладка("Тело после выделения параметра (для подстановки из таблицы) %1", НовоеТело);

	КонецЦикла;

	Возврат НовоеТело;
КонецФункции // ВыделитьПараметрыДляПодстановкиТаблицы(НовоеТело, Параметры)

Функция ИзвлечьПараметрТаблица(Знач ТекстТаблицы, Параметры)
	Если Лев(ТекстТаблицы, 1) <> ВозможныеТипыНачалаСтроки.Таблица Тогда
		Возврат ТекстТаблицы;
	КонецЕсли;
	Таблица = ПолучитьТаблицу(ТекстТаблицы);
	ОписаниеПараметра = ВозможныеКлючиПараметров.Таблица;
	Начало = 100000;// чтобы параметр-таблица всегда шел последним в списке параметров

	ДобавитьПараметр(Параметры, ОписаниеПараметра, Таблица, Начало);

	Возврат ОписаниеПараметра;
КонецФункции // ИзвлечьПараметрТаблица(Тело, Параметры)

Функция СоздатьТаблицуПараметров()
	Рез = Новый ТаблицаЗначений;
	Рез.Колонки.Добавить("Тип");
	Рез.Колонки.Добавить("Значение");
	Рез.Колонки.Добавить("Начало");
	Возврат Рез;
КонецФункции // СоздатьТаблицуПараметров()

Функция ДобавитьПараметр(ТабПараметры, Знач Тип, Знач Значение, Знач Начало)
	НоваяСтрока = ТабПараметры.Добавить();
	НоваяСтрока.Тип = Тип;
	НоваяСтрока.Значение = Значение;
	НоваяСтрока.Начало = Начало;
	Возврат НоваяСтрока;
КонецФункции

Процедура ДобавитьПараметры(ТабНазначение, ТабИсточник)
	Для к = 0 По ТабИсточник.Количество() - 1 Цикл
		СтрокаПараметров = ТабИсточник[к];
		ДобавитьПараметр(ТабНазначение, СтрокаПараметров.Тип, СтрокаПараметров.Значение, СтрокаПараметров.Начало);
		Лог.Отладка("ДобавитьПараметры %1, тип %2, начало %3",
			СтрокаПараметров.Значение, СтрокаПараметров.Тип, СтрокаПараметров.Начало);
	КонецЦикла;
КонецПроцедуры

Функция ЭтоЧисло(Знач Строка)
	РегулярноеВыражение = РегулярныеВыражения.НеЧисло;
	Возврат Не РегулярноеВыражение.Совпадает(Строка);
КонецФункции

Функция ПолучитьТипШагаПоЛексеме(Знач Лексема)
	Возврат ТипыШагов[Лексема];
КонецФункции

Функция ЭтоКлючПараметра(Знач Строка)
	Для Каждого КлючЗначение Из ВозможныеКлючиПараметров Цикл
		Если КлючЗначение.Значение = Строка Тогда
			Возврат Истина;
		КонецЕсли;
	КонецЦикла;
	Возврат Ложь;
КонецФункции

Процедура СоздатьНовыеСценарииВУзлахДереваВместоСтруктурыСценария(СтрокиДерева)
	ТаблицаСтрокДереваСоСтруктуройСценария = Новый ТаблицаЗначений;
	ТаблицаСтрокДереваСоСтруктуройСценария.Колонки.Добавить("СтрокаДерева");
	ТаблицаСтрокДереваСоСтруктуройСценария.Колонки.Добавить("НачальныйНомерСтроки");

	Для Счетчик = 0 По СтрокиДерева.Количество() - 1 Цикл
		СтрокаДерева = СтрокиДерева[Счетчик];
		Если СтрокаДерева.ТипШага = ВозможныеТипыШагов.СтруктураСценария Тогда
			НоваяСтрокаТаблицы = ТаблицаСтрокДереваСоСтруктуройСценария.Добавить();
			НоваяСтрокаТаблицы.СтрокаДерева = СтрокаДерева; // таблица нужна, т.к. далее будет меняться порядок строк
			НоваяСтрокаТаблицы.НачальныйНомерСтроки = Счетчик;
		Иначе
			СоздатьНовыеСценарииВУзлахДереваВместоСтруктурыСценария(СтрокаДерева.Строки);
		КонецЕсли;
	КонецЦикла;
	ТаблицаСтрокДереваСоСтруктуройСценария.Сортировать("НачальныйНомерСтроки Убыв");

	МассивНовыхСтрок = Новый Массив;
	Для каждого Элемент Из ТаблицаСтрокДереваСоСтруктуройСценария Цикл
		Счетчик = Элемент.НачальныйНомерСтроки;
		СтрокаДерева = Элемент.СтрокаДерева;

		УзелПримеры = НайтиШагПримеры(СтрокаДерева);
		ТаблицаПримеров = ПолучитьТаблицу(УзелПримеры.Тело);
		ИспользоватьПервуюСтрокуКакИменаКолонокТаблицы(ТаблицаПримеров);

		СтрокаДерева.Строки.Удалить(УзелПримеры);
		СтрокиДерева.Удалить(СтрокаДерева);

		МассивНовыхСтрок = СоздатьНовыеСтрокиСценариевСПараметрамиИзПримеров(
					СтрокиДерева, Счетчик, СтрокаДерева, ТаблицаПримеров);

		Для каждого СтрокаДерева Из МассивНовыхСтрок Цикл
			СоздатьНовыеСценарииВУзлахДереваВместоСтруктурыСценария(СтрокаДерева.Строки);
		КонецЦикла;
	КонецЦикла;
КонецПроцедуры

Функция НайтиШагПримеры(Знач ИсходныйУзел)
	Для каждого Узел Из ИсходныйУзел.Строки Цикл
		Если Узел.ТипШага = ВозможныеТипыШагов.Примеры Тогда
			Возврат Узел;
		КонецЕсли;
	КонецЦикла;
	ВызватьИсключение СтрШаблон("Ошибка формата файла-фичи - Для структуры сценария не удалось найти примеры.
		|Название структуры сценария %1", ИсходныйУзел.Тело);
КонецФункции // НайтиШагПримеры(Строка)

Функция ПолучитьТаблицу(Знач ТекстТаблицы)

	ЧислоСтрок = СтрЧислоСтрок(ТекстТаблицы);

	ОписаниеОшибки = "Количество строк из таблицы должно быть больше 0, а это не так. Текст %1";
	Ожидаем.Что(ЧислоСтрок, СтрШаблон(ОписаниеОшибки, ТекстТаблицы)).Больше(0);

	РезТаблица = Новый ТаблицаЗначений;

	МассивЗначенийПервойСтроки = ПолучитьНаборЗначенийИзТекстовойСтрокиТаблицы(ТекстТаблицы, 1);
	Для НомерКолонки = 0 По МассивЗначенийПервойСтроки.Количество() - 1 Цикл
		РезТаблица.Колонки.Добавить("К" + НомерКолонки);
	КонецЦикла;

	НоваяСтрока = РезТаблица.Добавить();
	ЗаполнитьСтрокуТаблицы(МассивЗначенийПервойСтроки, НоваяСтрока, 0);

	Для НомерСтроки = 2 По ЧислоСтрок Цикл
		МассивЗначений = ПолучитьНаборЗначенийИзТекстовойСтрокиТаблицы(ТекстТаблицы, НомерСтроки);
		Если МассивЗначений = Неопределено Тогда
			Прервать;
		КонецЕсли;
		Ожидаем.Что(МассивЗначений, СтрШаблон("Получили неверное количество строк из таблицы. Текст %1", ТекстТаблицы))
				.ИмеетДлину(МассивЗначенийПервойСтроки.Количество());

		НоваяСтрока = РезТаблица.Добавить();
		ЗаполнитьСтрокуТаблицы(МассивЗначений, НоваяСтрока, НомерСтроки);
	КонецЦикла;
	Возврат РезТаблица;
КонецФункции // ПолучитьТаблицу(Тело)

Функция ПолучитьНаборЗначенийИзТекстовойСтрокиТаблицы(Знач ТекстТаблицы, Знач НомерСтроки)
	СтрокаТекстовойТаблицы = СтрПолучитьСтроку(ТекстТаблицы, НомерСтроки);
	Если НомерСтроки = 1 Тогда
		Лог.Отладка("Первая СтрокаПримеров %1", СтрокаТекстовойТаблицы);
	Иначе
		Лог.Отладка(" СтрокаПримеров №%2 %1", СтрокаТекстовойТаблицы, НомерСтроки - 1);
	КонецЕсли;
	МассивЗначений = ПолучитьНаборИзСтрокиТаблицы(СтрокаТекстовойТаблицы);
	Возврат МассивЗначений;
КонецФункции // ПолучитьНаборЗначенийИзТекстовойСтрокиТаблицы()

Процедура ЗаполнитьСтрокуТаблицы(Знач МассивЗначений, НоваяСтрока, Знач НомерСтроки)
	Для к = 0 По МассивЗначений.Количество() - 1 Цикл
		ЗначениеПараметра = МассивЗначений[к];

		//пытаемся привести к одному значению, все значения, кроме строки. Например, число, дата
		НайденныеПараметры = СоздатьТаблицуПараметров();
		ВыделитьПростыеЗначенияНеСтроки(ЗначениеПараметра, НайденныеПараметры);
		Если НайденныеПараметры.Количество() = 1 Тогда
			ЗначениеПараметра = НайденныеПараметры[0].Значение;
		КонецЕсли;

		Лог.Отладка("номер строки %3, значение из колонки %1 (для подстановки из таблицы) <%2>",
				к, ЗначениеПараметра, НомерСтроки - 1);
		НоваяСтрока[к] = ЗначениеПараметра;
	КонецЦикла;
КонецПроцедуры

Процедура ИспользоватьПервуюСтрокуКакИменаКолонокТаблицы(Таблица)
	Ожидаем.Что(Таблица.Количество(), "Количество строк из таблицы примеров должно быть больше 1, а это не так")
			.Больше(1);

	ПерваяСтрока = Таблица[0];

	Для НомерКолонки = 0 По Таблица.Колонки.Количество() - 1 Цикл
		ИмяКолонки = ПерваяСтрока[НомерКолонки];
		Лог.Отладка(СтрШаблон("имя колонки %1 (для подстановки из таблицы) <%2>", НомерКолонки, ИмяКолонки));
		Колонка = Таблица.Колонки[НомерКолонки];
		Колонка.Заголовок = ИмяКолонки;
	КонецЦикла;
	Таблица.Удалить(0);
КонецПроцедуры // ИспользоватьПервуюСтрокуКакИменаКолонокТаблицы(Таблица)

Функция ПолучитьНаборИзСтрокиТаблицы(Знач СтрокаТаблицы)
	РегулярноеВыражение = РегулярныеВыражения.ПараметрТаблицы;
	КоллекцияГруппСовпадений = РегулярноеВыражение.НайтиСовпадения(СтрокаТаблицы);
	Если КоллекцияГруппСовпадений.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;

	РезМассив = Новый Массив;
	Для к = 0 По КоллекцияГруппСовпадений.Количество() - 1 Цикл
		Совпадение = КоллекцияГруппСовпадений[к];
		ЗначениеПараметра = СокрП(Совпадение.Группы[1].Значение);// из-за особенностей регулярки могут быть пробелы сзади
		РезМассив.Добавить(ЗначениеПараметра);
	КонецЦикла;
	Возврат РезМассив;
КонецФункции // ПолучитьНаборИзСтрокиТаблицы()

Функция СоздатьНовыеСтрокиСценариевСПараметрамиИзПримеров(СтрокиДерева, Знач СчетчикСтрокиВДереве,
														Знач СтрокаДерева, Знач ТаблицаПримеров)
	МассивНовыхСтрок = Новый Массив;
	Для каждого СтрокаТаблицыПримеров Из ТаблицаПримеров Цикл
		НоваяСтрокаДерева = СтрокиДерева.Вставить(СчетчикСтрокиВДереве);
		СчетчикСтрокиВДереве = СчетчикСтрокиВДереве + 1;

		СкопироватьДерево(НоваяСтрокаДерева, СтрокаДерева);

		НоваяСтрокаДерева.ТипШага = ВозможныеТипыШагов.Сценарий;
		НоваяСтрокаДерева.Лексема = ВозможныеКлючевыеСлова.Сценарий;
		Лог.Отладка("Заменяю структуру сценария на узел, в котором тип шага %1, лексема <%2>, тело <%3>",
				НоваяСтрокаДерева.ТипШага, НоваяСтрокаДерева.Лексема, НоваяСтрокаДерева.Тело);

		МассивНовыхСтрок.Добавить(НоваяСтрокаДерева);

		ЗаменитьПараметрыУзлаНаПараметрыИзСтрокиПримеров(НоваяСтрокаДерева, СтрокаТаблицыПримеров, ТаблицаПримеров.Колонки);
	КонецЦикла;
	Возврат МассивНовыхСтрок;
КонецФункции // СоздатьНовыеСтрокиСценариевСПараметрамиИзПримеров(Строка, УзелПримеры)

Процедура ЗаменитьПараметрыУзлаНаПараметрыИзСтрокиПримеров(СтрокаДерева, Знач СтрокаТаблицыПримеров,
															Знач КолонкиТаблицыПримеров)
	Если СтрокаДерева.ЕстьПараметрыДляТаблицы Тогда
		ЗначенияПараметров = Новый Соответствие;
		Для каждого Колонка Из КолонкиТаблицыПримеров Цикл
			ИмяКолонки = Колонка.Имя;
			ИмяПараметра = Колонка.Заголовок;
			ЗначенияПараметров.Вставить(ИмяПараметра, СтрокаТаблицыПримеров[ИмяКолонки]);

			Лог.Отладка("представление колонки <%3>, значение колонки <%2>, ИмяКолонки из таблицы <%1>,
				|тело узла - %4 ",
				ИмяКолонки, СтрокаТаблицыПримеров[ИмяКолонки], ИмяПараметра, СтрокаДерева.Тело);
		КонецЦикла;
		Для каждого Параметр Из СтрокаДерева.Параметры Цикл
			Если Параметр.Тип <> ВозможныеКлючиПараметров.ПараметрДляТаблицы Тогда
				Продолжить;
			КонецЕсли;
			ИмяПараметра = Параметр.Значение;
			Параметр.Значение = ЗначенияПараметров[ИмяПараметра];

			СтрокаДерева.Тело = СтрЗаменить(СтрокаДерева.Тело,
								"<" + ИмяПараметра + ">", "<" + Параметр.Значение + ">");

			Лог.Отладка("ИмяПараметра из таблицы <%1>, новое значение <%2>, ЗначенияПараметров[ИмяПараметра] <%3>,
				|тело узла - %4, тип %5 ",
				ИмяПараметра, Параметр.Значение, ЗначенияПараметров[ИмяПараметра], СтрокаДерева.Тело, Параметр.Тип);
		КонецЦикла;
	КонецЕсли;
	Для каждого ПодчиненнаяСтрока Из СтрокаДерева.Строки Цикл
		ЗаменитьПараметрыУзлаНаПараметрыИзСтрокиПримеров(ПодчиненнаяСтрока, СтрокаТаблицыПримеров, КолонкиТаблицыПримеров);
	КонецЦикла;
КонецПроцедуры

Процедура ВставитьУзлыКонтекстовВУзлыСценариевПодчиненныхКонтексту(СтрокиДерева, Знач СчетчикСтрокиВДереве = 0,
																Знач УзелКонтекста = Неопределено)
	Для Счетчик = СчетчикСтрокиВДереве По СтрокиДерева.Количество() - 1  Цикл

		СтрокаДерева = СтрокиДерева[Счетчик];
		Лог.Отладка("	Лексема <%1>, Тело <%2>, уровень <%3>, уровень() %4",
					СтрокаДерева.Лексема, СтрокаДерева.Тело, СтрокаДерева.УровеньЛексемы, СтрокаДерева.Уровень());
		Если СтрокаДерева.Уровень() > 1 Тогда
			Прервать;
		КонецЕсли;
		Если СтрокаДерева.ТипШага = ВозможныеТипыШагов.Контекст  Тогда
			Лог.Отладка(СтрШаблон("Найден контекст <%1>", СтрокаДерева.Тело));
			СтрокиДерева.Удалить(СтрокаДерева);
			ВставитьУзлыКонтекстовВУзлыСценариевПодчиненныхКонтексту(СтрокиДерева, Счетчик, СтрокаДерева);
			Прервать;

		Иначе
			Если УзелКонтекста <> Неопределено Тогда
				Если СтрокаДерева.УровеньЛексемы = УзелКонтекста.УровеньЛексемы Тогда
					МассивСтрокДляВставкиКонтекста = Новый Массив;
					МассивСтрокДляВставкиКонтекста.Добавить(СтрокаДерева);
					ВставитьУзелКонтекста(МассивСтрокДляВставкиКонтекста, УзелКонтекста);
				КонецЕсли;
			КонецЕсли;

		КонецЕсли;
	КонецЦикла;

	Для каждого СтрокаДерева Из СтрокиДерева Цикл
		ВставитьУзлыКонтекстовВУзлыСценариевПодчиненныхКонтексту(СтрокаДерева.Строки);
	КонецЦикла;
КонецПроцедуры

Процедура ВставитьУзелКонтекста(Знач МассивСтрокДляВставкиКонтекста, Знач УзелКонтекста)
	Для каждого СтрокаСценария Из МассивСтрокДляВставкиКонтекста Цикл
		Лог.Отладка("Вставляю контекст для строки <%1>, контекст <%2>", СтрокаСценария.Тело, УзелКонтекста.Тело);

		НоваяСтрока = СтрокаСценария.Строки.Вставить(0);
		СкопироватьДерево(НоваяСтрока, УзелКонтекста);
		ПоказатьДеревоВРежимеОтладки(СтрокаСценария, "          ");
	КонецЦикла;
КонецПроцедуры

Функция ПолучитьЯзыкФичи(Знач ОчереднаяСтрока)
	Перем МЕТКА_ЯЗЫКА;

	МЕТКА_ЯЗЫКА = "language:";

	Язык = "";
	Поз = Найти(ОчереднаяСтрока, МЕТКА_ЯЗЫКА);
	Если  Поз > 0 Тогда
		Язык = СокрЛП(Сред(ОчереднаяСтрока, Поз + СтрДлина(МЕТКА_ЯЗЫКА)));
	КонецЕсли;
	Возврат Язык;
КонецФункции

// возвращает строку многострочного текста, сдвинутую влево на количество пробелов из первой строки
// например, вместо строки
//"""
//	первая строка
//	вторая строка
//"""
//будет получена строка
//"""
//первая строка
//вторая строка
//"""
Функция ПолучитьМногострочныйТекст(Фича)
	ДлинаСтрокиНачалаМногострочногоТекста = СтрДлина(ВозможныеТипыНачалаСтроки.МногострочныйТекст);

	ЭтоПерваяСтрока = Истина;
	Отступ = 0;
	МногострочнаяСтрока = "";
	Пока Истина Цикл
		ОчереднаяСтрока = ПолучитьОчереднуюСтрокуФичи(Фича, Ложь);
		Если ЭтоПерваяСтрока Тогда
			ЭтоПерваяСтрока = Ложь;
			ДлинаСтроки = СтрДлина(ОчереднаяСтрока);
			Отступ = 1;
			Пока Отступ <= ДлинаСтроки Цикл
				СимволСлева = Сред(ОчереднаяСтрока, Отступ, 1);
				Если СимволСлева = " " или СимволСлева = Символы.Таб Тогда
					Отступ = Отступ + 1;
				Иначе
					Прервать;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
		Если ОчереднаяСтрока = Неопределено
				или Лев(СокрЛ(ОчереднаяСтрока), ДлинаСтрокиНачалаМногострочногоТекста) = ВозможныеТипыНачалаСтроки.МногострочныйТекст Тогда
			Прервать;
		КонецЕсли;
		// проверю, нет ли в отсекаемоей левой части строки непробельных символов, которые нужно сохранить
		ПозицияПервогоНеПробельногоСимвола = НайтиПозициюПервогоНеПробельногоСимвола(Лев(ОчереднаяСтрока, Отступ - 1));

		ДобавляемаяСтрока = Сред(ОчереднаяСтрока, Мин(Отступ, ПозицияПервогоНеПробельногоСимвола));
		МногострочнаяСтрока = МногострочнаяСтрока + ДобавляемаяСтрока + Символы.ПС;
	КонецЦикла;
	Если Прав(МногострочнаяСтрока, 1) = Символы.ПС Тогда
		МногострочнаяСтрока = Сред(МногострочнаяСтрока, 1, СтрДлина(МногострочнаяСтрока) - 1);
	КонецЕсли;
	МногострочнаяСтрока = ВозможныеТипыНачалаСтроки.МногострочныйТекст + Символы.ПС + МногострочнаяСтрока
			+ Символы.ПС + ВозможныеТипыНачалаСтроки.МногострочныйТекст;
	Возврат МногострочнаяСтрока;
КонецФункции // ПолучитьМногострочныйТекст()

Функция НайтиПозициюПервогоНеПробельногоСимвола(Знач Строка)
	КоллекцияГруппСовпадений = РегулярныеВыражения.ПробельныеСимволы.НайтиСовпадения(Строка);
	Если КоллекцияГруппСовпадений.Количество() = 0 Тогда
		Возврат СтрДлина(Строка) + 1;
	КонецЕсли;
	Совпадение = КоллекцияГруппСовпадений[0];
	Значение = Совпадение.Группы[0].Значение;
	Поз = Совпадение.Группы[0].Индекс;
	Возврат Поз;

КонецФункции // НайтиПозициюПервогоНепробельногоСимвола()

Функция ПолучитьТелоТаблицыДанных(Фича, ОчереднаяСтрока)
	Рез = ОчереднаяСтрока;
	Пока Истина Цикл
		ОчереднаяСтрока = ПолучитьОчереднуюСтрокуФичи(Фича, Ложь);
		Если ОчереднаяСтрока = Неопределено Тогда
			Прервать;
		КонецЕсли;
		ОчереднаяСтрока = СокрЛП(ОчереднаяСтрока);

		Если Лев(ОчереднаяСтрока, 1) <> ВозможныеТипыНачалаСтроки.Таблица Тогда
			Фича.ВернутьсяНаСтрокуНазад();
			Прервать;
		КонецЕсли;
		Рез  = Рез  + Символы.ПС + ОчереднаяСтрока;
	КонецЦикла;
	Возврат Рез;
КонецФункции // ПолучитьТелоТаблицыДанных(Фича)

Функция ВозможныеТипыНачалаСтроки()
	Если ВозможныеТипыНачалаСтроки = Неопределено Тогда
		Рез = Новый Структура;
		Рез.Вставить("Комментарий", "#");
		Рез.Вставить("Метка", "@");
		Рез.Вставить("Таблица", "|");
		Рез.Вставить("ОбычныйТекст", 1);
		Рез.Вставить("МногострочныйТекст", """""""");
		ВозможныеТипыНачалаСтроки = Новый ФиксированнаяСтруктура(Рез);
	КонецЕсли;
	Возврат ВозможныеТипыНачалаСтроки;
КонецФункции

Процедура Инициализация()
	Лог = Логирование.ПолучитьЛог(ИмяЛога());
	//Лог.УстановитьУровень(УровниЛога.Отладка);

	Язык = "ru";

	ВозможныеКлючевыеСлова = ВозможныеКлючевыеСлова();
	ВозможныеТипыШагов = ВозможныеТипыШагов();
	ВозможныеТипыНачалаСтроки = ВозможныеТипыНачалаСтроки();
	ВозможныеКлючиПараметров = ВозможныеКлючиПараметров();
	ВозможныеХуки = ВозможныеХуки();

	ОписанияЛексем = ОписанияЛексем();

	УровниЛексем = ПолучитьУровниЛексем();
	ТипыШагов = ПолучитьТипыШагов();

	СоответствиеЯзыкКлючевыеСлова = Создать_СоответствиеЯзыкКлючевыеСлова();
	СоответствиеКлючевыеСлова = СоответствиеЯзыкКлючевыеСлова.Получить(Язык);

	РегулярныеВыражения = СоздатьРегулярныеВыражения();
	НаборЗаменДляНормализацииАдресаШага = СоздатьНаборЗаменДляНормализацииАдресаШага();
КонецПроцедуры

Функция Создать_СоответствиеЯзыкКлючевыеСлова()
	Рез = Новый Соответствие;
	Рез.Вставить("ru", СоздатьСоответствиеКлючевыхСлов_ru());
	Возврат Рез;
КонецФункции

Функция СоздатьСоответствиеКлючевыхСлов_ru()
	Рез = Новый Соответствие;

	Рез.Вставить("допустим", ВозможныеКлючевыеСлова.Допустим);
	Рез.Вставить("дано", ВозможныеКлючевыеСлова.Допустим);
	Рез.Вставить("пусть", ВозможныеКлючевыеСлова.Допустим);

	Рез.Вставить("если", ВозможныеКлючевыеСлова.Когда);
	Рез.Вставить("когда", ВозможныеКлючевыеСлова.Когда);

	Рез.Вставить("тогда", ВозможныеКлючевыеСлова.Тогда);
	Рез.Вставить("то", ВозможныеКлючевыеСлова.Тогда);

	Рез.Вставить("и", ВозможныеКлючевыеСлова.Также);
	Рез.Вставить("к тому же", ВозможныеКлючевыеСлова.Также);
	Рез.Вставить("также", ВозможныеКлючевыеСлова.Также);

	Рез.Вставить("но", ВозможныеКлючевыеСлова.Но);
	Рез.Вставить("а", ВозможныеКлючевыеСлова.Но);

	Рез.Вставить("функциональность:", ВозможныеКлючевыеСлова.Функциональность);
	Рез.Вставить("функционал:", ВозможныеКлючевыеСлова.Функциональность);
	Рез.Вставить("функция:", ВозможныеКлючевыеСлова.Функциональность);
	Рез.Вставить("свойство:", ВозможныеКлючевыеСлова.Функциональность);

	Рез.Вставить("предыстория:", ВозможныеКлючевыеСлова.Контекст);
	Рез.Вставить("контекст:", ВозможныеКлючевыеСлова.Контекст);
	Рез.Вставить("сценарий:",  ВозможныеКлючевыеСлова.Сценарий);
	Рез.Вставить("структура сценария:", ВозможныеКлючевыеСлова.СтруктураСценария);

	Рез.Вставить("примеры:", ВозможныеКлючевыеСлова.Примеры);

	Возврат Рез;
КонецФункции

Функция ОписанияЛексем()
	Если ОписанияЛексем = Неопределено Тогда
		Рез = Новый ТаблицаЗначений;
		Рез.Колонки.Добавить("Ключ");
		Рез.Колонки.Добавить("Лексема");
		Рез.Колонки.Добавить("ТипШага");
		Рез.Колонки.Добавить("Уровень");

		ДобавитьЛексему(Рез, ВозможныеКлючевыеСлова.Функциональность, ВозможныеТипыШагов.Функциональность, 0);
		ДобавитьЛексему(Рез, ВозможныеКлючевыеСлова.Контекст, ВозможныеТипыШагов.Контекст, 20);
		ДобавитьЛексему(Рез, ВозможныеКлючевыеСлова.Сценарий, ВозможныеТипыШагов.Сценарий, 20);
		ДобавитьЛексему(Рез, ВозможныеКлючевыеСлова.СтруктураСценария, ВозможныеТипыШагов.СтруктураСценария, 20);
		ДобавитьЛексему(Рез, ВозможныеКлючевыеСлова.Примеры, ВозможныеТипыШагов.Примеры, 100);
		ДобавитьЛексему(Рез, ВозможныеКлючевыеСлова.Допустим, ВозможныеТипыШагов.Шаг, 100);
		ДобавитьЛексему(Рез, ВозможныеКлючевыеСлова.Когда, ВозможныеТипыШагов.Шаг, 100);
		ДобавитьЛексему(Рез, ВозможныеКлючевыеСлова.Тогда, ВозможныеТипыШагов.Шаг, 100);
		ДобавитьЛексему(Рез, ВозможныеКлючевыеСлова.Также, ВозможныеТипыШагов.Шаг, 100);
		ДобавитьЛексему(Рез, ВозможныеКлючевыеСлова.Но, ВозможныеТипыШагов.Шаг, 100);
		ДобавитьЛексему(Рез, ВозможныеКлючевыеСлова.Описание, ВозможныеТипыШагов.Описание, 200);

		ОписанияЛексем = Рез;
	КонецЕсли;
	Возврат ОписанияЛексем;
КонецФункции

Функция ДобавитьЛексему(Таблица, Ключ, ТипШага, Уровень)
	НоваяСтрока = Таблица.Добавить();
	НоваяСтрока.Ключ = Ключ;
	НоваяСтрока.Лексема = Ключ;
	НоваяСтрока.ТипШага = ТипШага;
	НоваяСтрока.Уровень = Уровень;

	Возврат НоваяСтрока;
КонецФункции

Функция ПолучитьУровниЛексем()
	Рез = Новый Структура;
	Для каждого Строка Из ОписанияЛексем Цикл
		Рез.Вставить(Строка.Ключ, Строка.Уровень);
	КонецЦикла;
	Возврат Рез;
КонецФункции

Функция ПолучитьТипыШагов()
	Рез = Новый Структура;
	Для каждого Строка Из ОписанияЛексем Цикл
		Рез.Вставить(Строка.Ключ, Строка.ТипШага);
	КонецЦикла;
	Возврат Новый ФиксированнаяСтруктура(Рез);
КонецФункции

Функция СоздатьРегулярныеВыражения()
	Рез = Новый Структура;
	Рез.Вставить("НеЧисло", Новый РегулярноеВыражение("[^\d,]+"));
	// Даты вида 29.11.2020, 29-11-2020, 29/11/2020, 29.11.20, 29-11-20, 29/11/20,
	Рез.Вставить("Дата", Новый РегулярноеВыражение("(\d{2})[\.\-\/](\d{2})[\.\-\/](\d{2,4})"));
	Рез.Вставить("ЧислоИлиСловоСЧислом", Новый РегулярноеВыражение("(\d+(,\d+){0,1})|(-?\d+(,\d){0,1})+")); //Когда я использую 5 как 5число5
	Рез.Вставить("МногострочныйТекст", Новый РегулярноеВыражение("\s*""""""\n\r*((.*\n\r*)+)\s*"""""""));
	Рез.Вставить("ПараметрДляТаблицы", Новый РегулярноеВыражение("<([^>]+)>"));
	Рез.Вставить("ПараметрТаблицы", Новый РегулярноеВыражение("\|\s*([^\|]+)\s*"));
	Рез.Вставить("ПробельныеСимволы", Новый РегулярноеВыражение("[^\s]"));
	Возврат Новый ФиксированнаяСтруктура(Рез);
КонецФункции // СоздатьРегулярныеВыражения()

Функция СоздатьНаборЗаменДляНормализацииАдресаШага()
	Соответствие = Новый Соответствие;
	Соответствие.Вставить(" ", "_");
	Соответствие.Вставить(",", "_");
	Соответствие.Вставить("(", "_");
	Соответствие.Вставить(")", "_");
	Соответствие.Вставить(";", "_");
	Соответствие.Вставить(".", "_");

	Соответствие.Вставить("`", "_");
	Соответствие.Вставить("~", "_");
	Соответствие.Вставить("!", "_");
	Соответствие.Вставить("@", "_");
	Соответствие.Вставить("#", "_");
	Соответствие.Вставить("$", "_");
	Соответствие.Вставить("%", "_");
	Соответствие.Вставить("^", "_");
	Соответствие.Вставить("&", "_");
	Соответствие.Вставить("*", "_");
	Соответствие.Вставить("'", "_");
	Соответствие.Вставить("/", "_");
	Соответствие.Вставить("\", "_");
	Соответствие.Вставить(":", "_");
	Соответствие.Вставить("-", "_");
	Соответствие.Вставить("+", "_");
	Соответствие.Вставить("=", "_");
	Соответствие.Вставить("№", "_");
	Соответствие.Вставить("?", "_");
	Соответствие.Вставить("<", "_");
	Соответствие.Вставить(">", "_");
	Соответствие.Вставить("[", "_");
	Соответствие.Вставить("]", "_");
	Соответствие.Вставить("{", "_");
	Соответствие.Вставить("}", "_");

	Возврат Соответствие;
КонецФункции // СоздатьНаборЗаменДляНормализацииАдресаШага()

// }

///////////////////////////////////////////////////////////////////
// Точка входа

Инициализация();
